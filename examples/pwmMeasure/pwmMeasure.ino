/*
Example program to demonstarte usage od PWM sense library for 
PWM signal measures, estimating frequency and duty 

(c) Dejan Gjorgjevikj, 2017
Revised:
23.08.2018 - clean up ...
09.09.2018 - renaming, clean up, simlify

https://github.com/Gjorgjevikj/PWMsense.git
*/

#include <PWMsense.h>
#include <PWMinfo.h>

// seting up some board specifics 
// ... PWM generation is 8 bit precise on ATmega 
#if defined(ARDUINO_ARCH_AVR)
#pragma message("ARDUINO_ARCH_AVR defined!")
#define PCT(x) ((x)*256/100) 
#define pct *256/100

// generating PWM to connect it for measuring 
// on the same device for testing purposes only... if you have no other source
const static int OUT_PWM_PIN1 = 10;
const static int OUT_PWM_PIN2 = 11;
void setPwmFrequency(int pin, int divisor);

// pins to be used for measuring PWM signals
// we can configure ANY pin that supports Pin Change interrupt 
// and any number of them simultaneosly (subject to maximum speed, duty, produced code size...)
const static int MEASURE_PIN1 = 4; // we could choose any pin
const static int MEASURE_PIN2 = 5; // we could choose any pin
const static int MEASURE_PIN3 = 6; // we could choose any pin
const static int MEASURE_PIN4 = 12; // we could choose any pin
const static int ANALOG_IN_PIN = A0;
// connect the wiper of a potentiometer to A0 an the fixed ends to Vcc and Gnd 
// to cange the duty of the signal generated on OUT_PWM_PIN1 and the inverse duty to OUT_PWM_PIN2

#elif defined (ESP8266) 

#pragma message("ESP8266 defined!")
#define PCT(x) ((x)*PWMRANGE/100)
#define pct *PWMRANGE/100

// generating PWM to connect it for measuring if you have no other source
// on the same device for testing purposes only... if you have no other source
const static int OUT_PWM_PIN1 = D5;
const static int OUT_PWM_PIN2 = D6;

// pins to be used for measuring PWM signals
const static int MEASURE_PIN1 = D1; // we could choose any pin
const static int MEASURE_PIN2 = D2; // we could choose any pin
const static int MEASURE_PIN3 = D3; // we could choose any pin
const static int MEASURE_PIN4 = D4; // we could choose any pin
const static int ANALOG_IN_PIN = A0;

#endif

// Macros that print out the estimate of the frequency and the duty of the running signal on monitoring pin
#define REPLC(_pm_)  { \
float dty = _pm_::duty(); \
float frq = _pm_::frequency(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" | "); \
}

// also reports the time monitoring is running and averaging the measures
#define REP(_pm_)  { \
float dty = _pm_::duty(); \
float frq = _pm_::frequency(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" (");Serial.print(_pm_::timeCounting()/1000000);Serial.print(")"); \
Serial.print(" | "); \
}

// macro that starts monitoring PWM signal on pin _mp_
// waits until n cycles has been recorded or t miliseconds have passed - whichever comes first
// stops monitoring the signal and reports the values
#define MPWM(_mp_,n,t) { \
typedef PWMsense<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(pm::pulseCount() < (n) && (millis() - start) < (t) ) \
  ; \
pm::end(); \
float dty = pm::duty(); \
float frq = pm::frequency(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print(pm::pulseCount()); Serial.print(","); Serial.print((millis() - start)); Serial.print(") "); \
}

#define MPWMLC(_mp_,t) { \
typedef PWMinfo<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(!pm::valid() && millis()-start < (t)) \
  ; \
pm::end(); \
float dty = pm::duty(); \
float frq = pm::frequency(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print((millis() - start)); Serial.print(") "); \
}

// declare the object that will be bounded to pin to monitor the PWM signal
// since the objcts are generated by template and have only static functions 
// there is no constructor call, but rather a user defined type definition
typedef PWMsense<MEASURE_PIN1> pm1; // or use the macro PWMmonitor(pm1,MEASURE_PIN1);
PWMmonitor(pm2,MEASURE_PIN2); // equivalent to typedef PWMsense<MEASURE_PIN2> pm2; 
typedef PWMinfo<MEASURE_PIN3> pm3; // equivalent to PWMinf(pm31, MEASURE_PIN3);
PWMinf(pm4, MEASURE_PIN4);

void toogleLed()
{
	static bool ledOn = false;
	ledOn = !ledOn;
	digitalWrite(LED_BUILTIN, ledOn);
}

const unsigned long max_wait_time = 1000;

void setup() 
{
  Serial.begin(9600);
  pinMode(OUT_PWM_PIN1, OUTPUT);
  pinMode(OUT_PWM_PIN2, OUTPUT);
  analogWrite(OUT_PWM_PIN1, 45 pct);
  analogWrite(OUT_PWM_PIN2, 55 pct);

  Serial.println("One-time measurement ...");
  delay(500);

  // Estimate the frequency using only 1 cycle waiting no more than 100ms
  float f = OnePulseFreqEstimate<MEASURE_PIN1>(100);
  Serial.print("1-pulse f=");
  Serial.print(f);
  Serial.print("Hz");
  // Estimate the duty using only 1 cycle waiting no more than 100ms
  float d = OnePulseDutyEstimate<MEASURE_PIN1>(100);
  Serial.print("1-pulse d=");
  Serial.print(d);
  Serial.print("%");

  // Estimate the frequency on 10 cycles and waiting no more than 200ms
  f = FreqEstimate<MEASURE_PIN2>(200);
  Serial.print("10-pulse f=");
  Serial.print(f);
  Serial.print("Hz");
  // Estimate the duty using only 1 cycle waiting no more than 150ms
  d = DutyEstimate<MEASURE_PIN3>(150);
  Serial.print("10-pulse d=");
  Serial.print(d);
  Serial.print("%");

  Serial.println();

  // begin monitoring
  pm1::begin(); 
  pm2::begin();
  pm3::begin();
  pm4::begin();

  Serial.print("pin");
  Serial.print(pm1::pin());
  Serial.print(" & pin");
  Serial.print(pm2::pin());
  Serial.println(" monitored continously averaging frequency and duty");

  Serial.print("pin");
  Serial.print(pm3::pin());
  Serial.print(" & pin");
  Serial.print(pm4::pin());
  Serial.println(" monitored using last cycle only");

  float d2, d4;
  unsigned long t, c;

  // statat fresh estimate
  pm1::reset();

  t = millis();
  while (millis() - t < max_wait_time)
  {
	  // do other stuff
	  // chack if sufficent pulses has passed to do the estimete
	  // can stall if no change in signal (no pulses)!!!
	  if (pm1::pulseCount() > 3)
		  break;
  }
  f = pm1::frequency();
  Serial.print("f= ");
  Serial.print(f);
  Serial.print(" ... ");

  c = 100000;
  // do some other stuff...
  while (c--)
	  ;

  // check the averaged frequency ... still counting
  f = pm1::frequency();
  Serial.print("f= ");
  Serial.print(f);
  Serial.print(" ... ");

  analogWrite(OUT_PWM_PIN1, 10 pct);
  pm2::reset();
  pm4::reset();
  delay(500);
  d2 = pm2::duty();
  d4 = pm4::duty();
  Serial.print(" d2= ");
  Serial.print(d2);
  Serial.print(" d4= ");
  Serial.print(d4);
  Serial.print(" ... ");

  // change the duty
  analogWrite(OUT_PWM_PIN1, 90 pct);
  delay(500);
  d2 = pm2::duty();
  d4 = pm4::duty();
  Serial.print(" d2= ");
  Serial.print(d2);
  Serial.print(" d4= ");
  Serial.print(d4);
  Serial.println();

  Serial.println("You can change the duty using the pot @ A0");
  pm1::reset();
  pm2::reset();
  pm3::reset();
  pm4::reset();


  delay(100);
  
}

//int cucl=0;
unsigned long ms = 0;

// There are basically 2 ways to use this library
// 1. Setting the measurement (installing the interrupt that will count the will record the timing of the pulseCount) 
//    and read out the measures after some time has passed or after a certain number of pulseCount have been encountered
// 2. Continually monitoring the signal on a pin, avearging over time - better estimate on stabile signals
// ... there can be yet another way ... using a timer interrupt and setting a callback function to be called to read the measures

void loop() 
{
	int aval = analogRead(ANALOG_IN_PIN);
#if defined(ARDUINO_ARCH_AVR)
	// on Arduino analogRead is 10 bit (0-1023), analogWrite is 8 bit (0-255)
	analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, 255));
	analogWrite(OUT_PWM_PIN2, map(aval, 0, 1023, 255, 0));
#elif defined (ESP8266) 
	// on ESP8266 analogRead is 10 bit (0-1023), analogWrite is initially 10 bit (0-PWMRANGE)
	analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, PWMRANGE));
	analogWrite(OUT_PWM_PIN2, map(aval, 0, 1023, PWMRANGE, 0));
#endif
	// ... will continually report the duty cycle and the Pulse Repetition Frequency of the PWM signal
	// averaging over time (since begin() was called), interrupts are working all the time...
	if (millis() - ms > 1000)
	{
		ms = millis();

		Serial.print(aval);
		Serial.print(" ");
		
		REP(pm1);
		REP(pm2);
		REPLC(pm3);
		REPLC(pm4);
		
		Serial.println(); 
		toogleLed();
	}

	// we can reset the counters to start reevaluation of the duty and frequency by calling reset()
	// that is necessary when the signal has changed 
	// after changing the frequency and/or duty the firs two monitors that are averaging the values will give inaccurate results 
	// they have to be resetted
	// on the other hand averaging gives mor accurate values on unstabile signals
	// the last two monitors that give the values considering the last cycle only will change immediately

	// check if there is anything entered on serial ...
#if defined(ARDUINO_ARCH_AVR)
	if (Serial.available())
	{
		char ch = Serial.read();
		unsigned long divisor = 0;
		switch (ch)
		{
		case '0': pm1::reset(); break;
		case '1': divisor = 1024;  break;
		case '2': divisor = 256;  break;
		case '3': divisor = 128;  break;
		case '4': divisor = 64;  break;
		case '5': divisor = 32;  break;
		case '6': divisor = 8;  break;
		case '7': divisor = 1; break;
		}
		if (divisor)
		{
			noInterrupts();
			pm1::reset();
			setPwmFrequency(OUT_PWM_PIN1, divisor);
			interrupts();
		}
		if (divisor == 1)
			Serial.println("This seems to high for me, but I'll try...");
	}

#elif defined (ESP8266) 

	if (Serial.available())
	{
		char ch = Serial.read();
		unsigned long int freq2set = 0UL;
		switch (ch)
		{
		case '0': pm1::reset(); break;
		case '1': freq2set = 32UL; break;
		case '2': freq2set = 125UL; break;
		case '3': freq2set = 250UL; break;
		case '4': freq2set = 500UL;  break;
		case '5': freq2set = 1000UL;  break;
		case '6': freq2set = 2000UL;  break;
		case '7': freq2set = 4000UL;  break;
		case '8': freq2set = 8000UL;  break;
		case '9': freq2set = 16000UL;  break;
		case 'a':
		case 'A': freq2set = 24000UL; break;
		case 'b':
		case 'B': freq2set = 32000UL;
			Serial.println("Ich, uh, ... this is pretty fast...");
			break;
		case 'c':
		case 'C': freq2set = 40000UL;
			Serial.println("This seems to high for me, but I'll try...");
			break;
		}
		if (ch != '0' && freq2set != 0)
		{
			//			noInterrupts();
			analogWriteFreq(freq2set);
			analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, PWMRANGE));
			//			interrupts();
			Serial.print("Frequency set to: ");
			Serial.println(freq2set);
			pm1::reset();
		}
		//Serial.print("PWM frq. changed to: ");
		//Serial.println(ch);
	}
#endif
	yield();
}

// for changing the frequency od pwm on AVR
#if defined(ARDUINO_ARCH_AVR)
void setPwmFrequency(int pin, int divisor) {
	byte mode;
	if (pin == 5 || pin == 6 || pin == 9 || pin == 10) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 64: mode = 0x03; break;
		case 256: mode = 0x04; break;
		case 1024: mode = 0x05; break;
		default: return;
		}
		if (pin == 5 || pin == 6) {
			TCCR0B = TCCR0B & 0b11111000 | mode;
		}
		else {
			TCCR1B = TCCR1B & 0b11111000 | mode;
		}
	}
	else if (pin == 3 || pin == 11) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 32: mode = 0x03; break;
		case 64: mode = 0x04; break;
		case 128: mode = 0x05; break;
		case 256: mode = 0x06; break;
		case 1024: mode = 0x07; break;
		default: return;
		}
		TCCR2B = TCCR2B & 0b11111000 | mode;
	}
}
#endif

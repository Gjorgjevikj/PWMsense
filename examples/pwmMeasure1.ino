/*
Example program to demonstarte usage od PWM sense library for 
PWM signal measures, estimating frequency and duty 

(c) Dejan Gjorgjevikj, 2017
Revised:
23.08.2018 - clean up ...

https://github.com/Gjorgjevikj/PWMsense.git
*/

#include <PWMsense.h>
#include <PWMinfo.h>

// seting up some board specifics 
// ... PWM generation is 8 bit precise on ATmega 
#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)
#pragma message("__AVR_ATmega328P__ || __AVR_ATmega168__ defined!")
#define PCT(x) ((x)*256/100) 
#define pct *256/100

// generating PWM to connect it for measuring 
// on the same device for testing purposes only... if you have no other source
#define OUT_PWM_PIN 10
#define OUT_PWM_PIN2 11

// pins to be used for measuring PWM signals
// we can configure ANY pin that supports Pin Change interrupt 
// and any number of them simultaneosly (subject to maximum speed, duty, produced code size...)
#define MEASURE_PIN1 4 // we could choose any pin
#define MEASURE_PIN2 5 // we could choose any pin
#define MEASURE_PIN3 6 // we could choose any pin
#define MEASURE_PIN4 12 // we could choose any pin

#define ANALOG_IN_PIN A0

#endif

// ... PWM generation is 10 bit precise on ESP8266
#if defined (ESP8266) 
#pragma message("ESP8266 defined!")
#define PCT(x) ((x)*1024/100)
#define pct *1024/100
// generating PWM to connect it for measuring if you have no other source
#define OUT_PWM_PIN D5
// pins to be used for measuring PWM signals
#define MEASURE_PIN1 D1 // we could choose any pin
#define MEASURE_PIN2 D2 // we could choose any pin
#define MEASURE_PIN3 D3 // we could choose any pin
#define MEASURE_PIN4 D4 // we could choose any pin

//#define ANALOG_IN_PIN A0
#endif

int dummy = 0; //just to stop vMicro generating error on Release builds


// Macros that print out the estimate of the frequency and the duty of the running signal on monitoring pin
#define REPLC(_pm_)  { \
float dty = _pm_::dutyCycle(); \
float frq = _pm_::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" | "); \
}

// also reports the time monitoring is running and averaging the measures
#define REP(_pm_)  { \
float dty = _pm_::dutyCycle(); \
float frq = _pm_::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" (");Serial.print(_pm_::timeCounting()/1000000);Serial.print(")"); \
Serial.print(" | "); \
}


// macro that starts monitoring PWM signal on pin _mp_
// waits until n cycles has been recorded or t miliseconds have passed - whichever comes first
// stops monitoring the signal and reports the values
#define MPWM(_mp_,n,t) { \
typedef PWMsense<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(pm::pulseCount() < (n) && (millis() - start) < (t) ) \
  ; \
pm::end(); \
float dty = pm::dutyCycle(); \
float frq = pm::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print(pm::pulseCount()); Serial.print(","); Serial.print((millis() - start)); Serial.print(") "); \
}

#define MPWMLC(_mp_,t) { \
typedef PWMinfo<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(!pm::valid() && millis()-start < (t)) \
  ; \
pm::end(); \
float dty = pm::dutyCycle(); \
float frq = pm::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print((millis() - start)); Serial.print(") "); \
}

#define MPWMDBG(_mp) { \
Serial.println(); \
Serial.print(_mp::pulses.prevRiseTime ); Serial.print(", "); \
Serial.print(_mp::pulses.prevFallTime); Serial.print(", "); \
Serial.print(_mp::pulses.riseTime); Serial.print(", "); \
Serial.print(_mp::pulses.fallTime); Serial.println(); \
}

// declare the object that will be bounded to pin to monitor the PWM signal
// since the objcts are generated by template and have only static functions 
// there is no constructor call, but rather a user defined type definition
typedef PWMsense<MEASURE_PIN1> pm1; // or use the macro PWMmonitor(pm1,MEASURE_PIN1);
//PWMinf(pm1, MEASURE_PIN1);
PWMmonitor(pm2,MEASURE_PIN2); // equivalent to typedef PWMsense<MEASURE_PIN2> pm2; 
//PWMmonitor(pm3,MEASURE_PIN3);
//PWMmonitor(pm4,MEASURE_PIN4);
PWMinf(pm3, MEASURE_PIN3);
PWMinf(pm4, MEASURE_PIN4);

void setPwmFrequency(int pin, int divisor) {
	byte mode;
	if (pin == 5 || pin == 6 || pin == 9 || pin == 10) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 64: mode = 0x03; break;
		case 256: mode = 0x04; break;
		case 1024: mode = 0x05; break;
		default: return;
		}
		if (pin == 5 || pin == 6) {
			TCCR0B = TCCR0B & 0b11111000 | mode;
		}
		else {
			TCCR1B = TCCR1B & 0b11111000 | mode;
		}
	}
	else if (pin == 3 || pin == 11) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 32: mode = 0x03; break;
		case 64: mode = 0x04; break;
		case 128: mode = 0x05; break;
		case 256: mode = 0x06; break;
		case 1024: mode = 0x07; break;
		default: return;
		}
		TCCR2B = TCCR2B & 0b11111000 | mode;
	}
}

void toogleLed()
{
	static bool ledOn = false;
	ledOn = !ledOn;
	digitalWrite(LED_BUILTIN, ledOn);
}

const unsigned long max_wait_time = 1000;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pinMode(OUT_PWM_PIN, OUTPUT);
  pinMode(OUT_PWM_PIN2, OUTPUT);
  analogWrite(OUT_PWM_PIN, 45 pct);
  analogWrite(OUT_PWM_PIN2, 55 pct);

  Serial.println("One-time measurement ...");
  delay(500);

  // Estimate the frequency using only 1 cycle waiting no more than 100ms
  float f = OnePulseFreqEstimate<MEASURE_PIN1>(100);
  Serial.print("1-pulse f=");
  Serial.print(f);
  Serial.print("Hz");
  // Estimate the duty using only 1 cycle waiting no more than 100ms
  float d = OnePulseDutyEstimate<MEASURE_PIN1>(100);
  Serial.print("1-pulse d=");
  Serial.print(d);
  Serial.print("%");

  // Estimate the frequency on 10 cycles and waiting no more than 200ms
  f = FreqEstimate<MEASURE_PIN2>(200);
  Serial.print("10-pulse f=");
  Serial.print(f);
  Serial.print("Hz");
  // Estimate the duty using only 1 cycle waiting no more than 150ms
  d = DutyEstimate<MEASURE_PIN3>(150);
  Serial.print("10-pulse d=");
  Serial.print(d);
  Serial.print("%");

  Serial.println();

  // begin monitoring
  pm1::begin(); 
  pm2::begin();
  pm3::begin();
  pm4::begin();

  Serial.print("pin");
  Serial.print(pm1::pin());
  Serial.print(" & pin");
  Serial.print(pm2::pin());
  Serial.println(" monitored continously averaging frequency and duty");

  Serial.print("pin");
  Serial.print(pm3::pin());
  Serial.print(" & pin");
  Serial.print(pm4::pin());
  Serial.println(" monitored using last cycle only");

  float d2, d4;
  unsigned long t, c;

  // statat fresh estimate
  pm1::reset();

  t = millis();
  while (millis() - t < max_wait_time)
  {
	  // do other stuff
	  // chack if sufficent pulses has passed to do the estimete
	  // can stall if no change in signal (no pulses)!!!
	  if (pm1::pulseCount() > 3)
		  break;
  }
  f = pm1::prf();
  Serial.print("f= ");
  Serial.print(f);
  Serial.print(" ... ");

  c = 100000;
  // do some other stuff...
  while (c--)
	  ;

  // check the averahed frequency ... still counting
  f = pm1::prf();
  Serial.print("f= ");
  Serial.print(f);
  Serial.print(" ... ");

  analogWrite(OUT_PWM_PIN, 10 pct);
  pm2::reset();
  pm4::reset();
  delay(500);
  d2 = pm2::dutyCycle();
  d4 = pm4::dutyCycle();
  Serial.print(" d2= ");
  Serial.print(d2);
  Serial.print(" d4= ");
  Serial.print(d4);
  Serial.print(" ... ");

  // change the duty
  analogWrite(OUT_PWM_PIN, 90 pct);
  delay(500);
  d2 = pm2::dutyCycle();
  d4 = pm4::dutyCycle();
  Serial.print(" d2= ");
  Serial.print(d2);
  Serial.print(" d4= ");
  Serial.print(d4);
  Serial.println();

  Serial.println("You can change the duty using the pot @ A0");
  pm1::reset();
  pm2::reset();
  pm3::reset();
  pm4::reset();


  delay(100);
  //pm1::end();
  //pm2::end();
  //pm3::end();
  //pm4::end();
}

//int cucl=0;
unsigned long ms = 0;

// There are basically 2 ways to use this library
// 1. Setting the measurement (installing the interrupt that will count the will record the timing of the pulseCount) 
//    and read out the measures after some time has passed or after a certain number of pulseCount have been encountered
// 2. Continually monitoring the signal on a pin, avearging over time - better estimate on stabile signals
// ... there can be yet another way ... using a timer interrupt and setting a callback function to be called to read the measures

void loop() 
{
	int aval = analogRead(ANALOG_IN_PIN);
	analogWrite(OUT_PWM_PIN, aval>>2);
	analogWrite(OUT_PWM_PIN2, 255 - (aval >> 2));

	// ... will continually report the duty cycle and the Pulse Repetition Frequency of the PWM signal
	// averaging over time (since begin() was called), interrupts are working all the time...
	if (millis() - ms > 1000)
	{
		ms = millis();

		Serial.print(aval);
		Serial.print(" ");
		
		REP(pm1);
	//	MPWMDBG(pm1);
		REP(pm2);
	//	REP(pm3);
	//	REP(pm4);
		REPLC(pm3);
		REPLC(pm4);
		
		Serial.println(); 
		toogleLed();
	}

	// we can reset the counters to start reevaluation of the duty and frequency by calling reset()
	// that is necessary when the signal has changed 
	// after changing the frequency and/or duty the firs two monitors that are averaging the values will give inaccurate results 
	// they have to be resetted
	// on the other hand averaging gives mor accurate values on unstabile signals
	// the last two monitors that give the values considering the last cycle only will change immediately
	if (Serial.available())
	{
		char ch = Serial.read();
		switch (ch)
		{
		case '0': pm1::reset(); pm2::reset(); pm3::reset(); pm4::reset(); break;
		case '1': setPwmFrequency(OUT_PWM_PIN, 1024);  break;
		case '2': setPwmFrequency(OUT_PWM_PIN, 256);  break;
		case '3': setPwmFrequency(OUT_PWM_PIN, 128);  break;
		case '4': setPwmFrequency(OUT_PWM_PIN, 64);  break;
		case '5': setPwmFrequency(OUT_PWM_PIN, 32);  break;
		case '6': setPwmFrequency(OUT_PWM_PIN, 8);  break;
		case '7': setPwmFrequency(OUT_PWM_PIN, 1);  
			Serial.println("This is too fast...: ");
			pm1::reset(); pm1::end();
			pm2::reset(); pm2::end();
			pm4::reset(); pm4::end();
			break;
		}
		//Serial.print("PWM frq. changed to: ");
		//Serial.println(ch);
	}


//  delay(1000);
}



/*
Example program to demonstarte usage od PWM sense library for 
PWM signal measures

(c) Dejan Gjorgjevikj, 2017
*/

#include "PWMsense.h"
#include "PWMinfo.h"

// seting up some board specifics 
// ... PWM generation is 8 bit precise on ATmega 
#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)
#pragma message("__AVR_ATmega328P__ || __AVR_ATmega168__ defined!")
#define PCT(x) ((x)*256/100) 
#define pct *256/100
// generating PWM to connect it for measuring if you have no other source
#define OUT_PWM_PIN 10
// pins to be used for measuring PWM signals
#define MEASURE_PIN1 4 // we could choose any pin
#define MEASURE_PIN2 5 // we could choose any pin
#define MEASURE_PIN3 6 // we could choose any pin
#define MEASURE_PIN4 12 // we could choose any pin
#endif

// ... PWM generation is 10 bit precise on ESP8266
#if defined (ESP8266) 
#pragma message("ESP8266 defined!")
#define PCT(x) ((x)*1024/100)
#define pct *1024/100
// generating PWM to connect it for measuring if you have no other source
#define OUT_PWM_PIN D5
// pins to be used for measuring PWM signals
#define MEASURE_PIN1 D1 // we could choose any pin
#define MEASURE_PIN2 D2 // we could choose any pin
#define MEASURE_PIN3 D3 // we could choose any pin
#define MEASURE_PIN4 D4 // we could choose any pin
#endif

int dummy = 0; //just to stop vMicro generating error on Release builds

#define REP(_pm_)  { \
float dty = _pm_::dutyCycle(); \
float frq = _pm_::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" (");Serial.print(_pm_::timeCounting()/1000000);Serial.print(")"); \
Serial.print(" | "); \
}

#define REPLC(_pm_)  { \
float dty = _pm_::dutyCycle(); \
float frq = _pm_::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" | "); \
}

// macro that starts monitoring PWM signal od pin _mp_
// waits until n cycles has been recorded or t miliseconds have passed - whichever comes first
// stops monitoring the signal and reports the PWM values
#define MPWM(_mp_,n,t) { \
typedef PWMsense<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(pm::pulseCount() < (n) && (millis() - start) < (t) ) \
  delay(1); \
pm::end(); \
float dty = pm::dutyCycle(); \
float frq = pm::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print(pm::pulseCount()); Serial.print(","); Serial.print((millis() - start)); Serial.print(") "); \
}

#define MPWMLC(_mp_,t) { \
typedef PWMinfo<_mp_> pm; \
pm::begin(); \
unsigned long start=millis(); \
while(!pm::valid() && millis()-start < (t)) \
  delay(1); \
pm::end(); \
float dty = pm::dutyCycle(); \
float frq = pm::prf(); \
Serial.print(dty); Serial.print("% @ "); Serial.print(frq); Serial.print("Hz"); \
Serial.print(" ("); Serial.print((millis() - start)); Serial.print(") "); \
}


// declare the object that will be bounded to pin to monitor the PWM signal
// since the objcts are generated by template and have only static functions 
// there is no constructor call, but rather a user defined type definition
typedef PWMsense<MEASURE_PIN1> pm1; // or use the macro PWMmonitor(pm1,MEASURE_PIN1);
PWMmonitor(pm2,MEASURE_PIN2); // equivalent to typedef PWMsense<MEASURE_PIN2> pm2; 
//PWMmonitor(pm3,MEASURE_PIN3);
//PWMmonitor(pm4,MEASURE_PIN4);
PWMinf(pm3, MEASURE_PIN3);
PWMinf(pm4, MEASURE_PIN4);


void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pinMode(OUT_PWM_PIN, OUTPUT);
  analogWrite(OUT_PWM_PIN, 45 pct);

  Serial.println("One-time measurement ...");
  delay(500);
  {
	  Serial.print("1: ");
	  MPWM(MEASURE_PIN1, 100, 100L); // measure for 100 cycles and no more than 100ms
	  Serial.print(" | 2: ");
	  MPWM(MEASURE_PIN2, 10, 1000L);
	  Serial.print(" | 3: ");
	  MPWM(MEASURE_PIN3, 2, 1L);
	  Serial.print(" | 4: ");
	  MPWM(MEASURE_PIN4, 2, 5000L);

	  Serial.println();
  }

  {
	  Serial.print("1: ");
	  MPWMLC(MEASURE_PIN1,100); // measure for 100 cycles and no more than 100ms
	  Serial.print(" | 2: ");
	  MPWMLC(MEASURE_PIN2,100);
	  Serial.print(" | 3: ");
	  MPWMLC(MEASURE_PIN3,1000);
	  Serial.print(" | 4: ");
	  MPWMLC(MEASURE_PIN4,200);

	  Serial.println();

  }

  Serial.println();
  pm1::begin(); // call the static function to begin monitoring
  pm2::begin();
  pm3::begin();
  pm4::begin();

  Serial.println("Ready...");

}

int cucl=0;

// There are basically 2 ways to use this library
// 1. Setting the measurement (installing the interrupt that will count the will record the timing of the pulseCount) 
//    and read out the measures after some time has passed or after a certain number of pulseCount have been encountered
// 2. Continually monitoring the signal on a pin, avearging over time - better estimate on stabile signals
// ... there can be yet another way ... using a timer interrupt and setting a callback function to be called to read the measures

void loop() {

	cucl++;
	Serial.print(cucl); 
	Serial.print(". "); 

	// ... will continually report the duty cycle and the Pulse Repetition Frequency of the PWM signal
	// averaging over time (since begin() was called), interrupts are working all the time...
	REP(pm1); 
	REP(pm2);
	REPLC(pm3);
	REPLC(pm4);

	Serial.println(); 

	// we can reset the counters to start reevaluation of the DC and prf by calling reset()
	// that is necessary when the signal has changed 

	if (Serial.available()) 
	{
		char ch = Serial.read();
		switch (ch)
		{
			case '0': pm4::reset(); pm3::reset(); pm2::reset(); 
			case '1': pm1::reset(); break;
			case '2': pm2::reset(); break;
			case '3': pm3::reset(); break;
			case '4': pm4::reset(); break;
		}
	}

  delay(1000);
}


